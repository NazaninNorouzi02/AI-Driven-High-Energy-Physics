# ================================================
# DO NOT EDIT THIS FILE
# ================================================
class TicTacToe:
    def __init__(self):
        #Creates a list of 9 zeros representing the 3×3 board in row-major order.
        #Convention: 0 means empty, 1 means X, -1 means O. 
        #Using 1 and -1 simplifies win detection (sums)
        self.board = [0] * 9   # 0 empty, 1 X, -1 O

        #Tracks whose turn it is. 1 means X moves next; -1  mean O. Starting player is X
        self.current_player = 1

    def clone(self):
        env = TicTacToe()
        #Copies the current board into the clone. is a shallow copy so the two lists don’t share memory.
        # This is critical for MCTS because we simulate many games without
        # affecting the real board.
        env.board = self.board[:]
        env.current_player = self.current_player
        #Return the cloned environment.
        return env

    def moves(self):
        # It loops through the board, collects the indices where the cell is still empty.
        return [i for i, v in enumerate(self.board) if v == 0]

    def play(self, move):
        # Play a move on the board. Updates the board and switches player.
        # Note: this modifies the board in-place
        self.board[move] = self.current_player
        self.current_player *= -1   # switch player

    def winner(self):
        # Check if there is a winner
        wins = [(0,1,2),(3,4,5),(6,7,8),(0,3,6),
                (1,4,7),(2,5,8),(0,4,8),(2,4,6)]
        for a,b,c in wins:
            s = self.board[a] + self.board[b] + self.board[c]
            # sum of 3 means X won, -3 means O won
            if s == 3: return 1
            if s == -3: return -1
        # if no empty spots, it's a draw
        if 0 not in self.board: return 0
        # otherwise game is ongoing
        return None
